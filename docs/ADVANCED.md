# 进阶

## 容器的后台运行

* 实现：`docker -d`
* 最开始，所有容器 init 进程都是从 docker daemon 进程 fork 出来。
* 会出现一个问题：daemon 挂掉，所有容器挂掉。
* 后来，Docker 使用了 containerd，即现在的 runc，可以实现 daemon 挂掉，但是容器依然存在。

* 因此需要父进程创建完成子进程后，`detach` 掉子进程。

实现原理

* 容器是 docker fork 出来的子进程。
* 如果父进程推出，子进程称为`孤儿进程`。
* 为了避免孤儿进程退出时无法释放所占用的资源而僵死，进程号为1的进程 init 会接受孤儿进程。

* 如果 detach 创建了容器，就不能再等待。因此，将容器内 init 进程启动起来后可以退出，然后由 OS 进程 ID 为 1 的 init 进程接管容器进程。

## 实现容器查看

* 实现：`docker ps`
* 需要做到：指定容器 name
* 记录容器信息到文件，存储到宿主机上

## 实现查看容器日志

* 实现: `docker logs`
* 修改：在创建容器时，调整标准输出重定向到 log 文件
* 执行 `docker logs` 时，获取 log 文件内容。 

## 实现进入容器 Namespace

* 实现：`docker exec`
* `setns`: 通过这个系统调用，根据提供的 PID 进入指定的 Namespace
    * 原理：打开 /proc/<pid>/ns 下的对应文件
* 问题：对于 Mount Namespace，一个具有多线程的进程是无法使用 setns 调用进入到对应的 NS 的。
* 因为 Go 每启动一个程序就会进入多线程状态，因此无法简单通过 Go 直接进行系统调用
* 需要借助 Cgo
* Cgo：

## 实现停止容器

## 容器删除

## 通过容器构建镜像

## 实现容器指定环境变量

## 